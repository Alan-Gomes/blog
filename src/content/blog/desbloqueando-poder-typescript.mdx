---
title: 'Desbloqueando o Poder do TypeScript'
pubDate: 2024-05-08
description: 'Dicas e truques para utilizar o melhor do TypeScript.'
excerpt: Entenda como escrever tipos que expressem melhor o seu c√≥digo e o torne mais previs√≠vel
tags: ['typescript']
---

import TypeScriptEditor from '@/components/editors/index.astro';

O TypeScript surgiu inicialmente como uma linguagem com o simples prop√≥sito de adicionar tipagem em cima do JavaScript.
Conforme novas vers√µes foram lan√ßadas, ela se tornou cada vez mais poderosa e hoje √© capaz de muitas coisas que voc√™ talvez n√£o saiba.
Nesse artigo, vamos entender qual a verdadeira utilidade do TypeScript e como desbloquear o melhor do seu potencial.

Antes de colocar a m√£o na massa e escrever c√≥digo, vamos falar um pouco sobre qual os benef√≠cios de uma linguagem tipada.
Quem j√° programou JavaScript _puro_ (sem tipagem) sabe que a aus√™ncia de tipos remove v√°rias barreiras e torna a escrita do c√≥digo muito mais pr√°tica.
Entretanto, conforme o tamanho do c√≥digo cresce e o n√∫mero de pessoas trabalhando no projeto aumenta, o que antes era um benef√≠cio pode se tornar justamente o contr√°rio.

> Apesar desse ponto de vista n√£o ser un√¢nime, o fato do crescimento do TypeScript √© um indicativo de que muitos desenvolvedores possuem esse sentimento

## Fases de feedback de problemas

No desenvolvimento de software, geralmente existem 4 fases onde s√£o gerados feedback de problemas, ou seja,
momentos em que s√£o detectadas falhas no sistema que demandam uma corre√ß√£o.
Cada fase acontece em um momento diferente e demanda um _custo cognitivo_ maior.

> üí° "Custo cognitivo" aqui se refere ao custo entre abandonar contexto de uma tarefa e precisar retomar posteriormente,
> quanto mais tempo passa, mais carga mental pode ser necess√°ria para compreender tudo novamente.

As fases de feedback s√£o:

1. **Compila√ß√£o**: o c√≥digo falha ao compilar e isso indica um problema estrutural. Nessa fase, o custo √© o menor pois voc√™ tem um feedback quase imediato.
2. **Testes locais/automatizados**: ao executar o c√≥digo, se identifica uma falha ao atender algum requisito do sistema, seja de forma automatizada ou n√£o.
   Nessa fase, apesar do feedback n√£o ser imediato, o custo costuma ainda ser baixo.
3. **Testes do profissional de QA**: ap√≥s haver uma publica√ß√£o em um ambiente espec√≠fico para testes, um profissional de QA valida se os requisitos foram atendidos.
   Nessa fase, o feedback pode levar desde horas at√© dias, portanto o custo j√° √© mais elevado.
4. **Utiliza√ß√£o pelo usu√°rio final**: ap√≥s o lan√ßamento de uma nova vers√£o, o sistema √© utilizado pelos seus usu√°rios, que identificam e reportam (ou n√£o) as falhas encontradas durante a utiliza√ß√£o.
   Aqui o custo √© alt√≠ssimo, considerando ainda que o desenvolvedor que corrige nem sempre √© o mesmo que desenvolveu.

Considerando essas fases e o custo de identificar um problema em cada um delas, fica constatado o √≥bvio: √© muito melhor ter erros de compila√ß√£o do que bugs encontrados pelo usu√°rio final.

## M√£o na massa

Agora vamos dar uma olhada em alguns exemplos de como usar o typescript para al√©m de meros tipos simples.
Cada exemplo mostra uma forma diferente de obter novos tipos, sendo os principais objetivos:
evitar repeti√ß√£o (quanto maior √© a reutiliza√ß√£o, mais f√°cil √© identificar efeitos colaterais em mudan√ßas) e aumentar precis√£o (quanto maior a precis√£o, menos margem para erros).

1. **Limitando valores poss√≠veis para um par√¢metro/vari√°vel**: No lugar de especificar um simples argumento `string`, especificamos exatamente quais os valores esperados.

<TypeScriptEditor
	code={`
  type Theme = 'light' | 'dark';
  declare function setTheme(theme: Theme): void;
  
  setTheme('light')
`}
	tryItNote="Tente trocar o argumento para um valor inv√°lido"
	note="Al√©m de garantir a seguran√ßa de tipos, deixa a informa√ß√£o clara no c√≥digo"
/>

2. **Transformando tipos j√° existentes**: Quando voc√™ tem dois ou mais tipos que compartilham estruturas semelhantes,
   pode ser interessante construir um baseado numa transforma√ß√£o do outro, evitando repeti√ß√£o de c√≥digo;

<TypeScriptEditor
	code={`
  interface Example {
    quantity: number;
    name: string;
    active: boolean;
  }
  
  interface ExtendsExample extends Example {
    details: object;
  }
  
  type A = Print<ExtendsExample>;
  
  interface OmitExample extends Omit<ExtendsExample, 'active'> {}
  
  type B = Print<OmitExample>;
  
  interface PickExample extends Pick<OmitExample, 'name' | 'details'> {}
  
  type C = Print<PickExample>;
`}
	tryItNote="Tente adicionar par√¢metros nas interfaces"
	note="Ao alterar uma interface as demais automaticamente propagam as mudan√ßas"
/>

3. **Derivando tipos a partir de valores constantes**: Quando voc√™ tem um objeto com uma estrutura constante,
   pode ser interessante inferir o tipo dele ao inv√©s de declarar uma interface apenas para isso.

<TypeScriptEditor
	code={`
  declare const process: { env: Record<string, string> };
  const environment = {
    database: {
      username: process.env.DB_USERNAME,
      password: process.env.DB_PASSWORD,
    },
  };
  
  // Criamos o tipo a partir do valor contido na vari√°vel
  type Environment = typeof environment;
  //   ^?
  
  const fontSizes = {
    sm: 8,
    md: 12,
    lg: 16,
  };
  
  // Extra√≠mos as chaves do objeto e criamos um tipo para elas
  type Size = keyof typeof fontSizes;
  //   ^?
  
  // Esse tipo garante o entrela√ßamento das informa√ß√µes
  declare function getFontSize(size: Size): number;
  getFontSize('sm');
`}
	tryItNote="Adicione um campo em environment ou remover 'sm' de fontSizes"
	note="Essa abordagem elimina a necessidade de repetir c√≥digo em declara√ß√£o de tipos"
/>

4. **Derivando tipos a partir do retorno de fun√ß√µes**: Quando voc√™ possui uma fun√ß√£o que transforma um dado,
   √© poss√≠vel inferir o retorno e criar um novo tipo a partir disso.

<TypeScriptEditor
	code={`
  interface UserDTO {
    name: string;
    createdAt: string;
  }
  
  // Criamos uma fun√ß√£o simples para transformar os dados do objeto DTO
  const parseUserDTO = (dto: UserDTO) => ({
    ...dto,
    createdAt: new Date(dto.createdAt),
  });
  
  // Criamos um tipo a partir do valor que √© retornado pela fun√ß√£o
  type User = ReturnType<typeof parseUserDTO>;
  //   ^?
  
  // Vari√°veis com esse tipo representar√£o o objeto que √© retornado pela fun√ß√£o
  declare const admin: User;
  admin.createdAt.getFullYear();
  //    ^?
`}
	tryItNote="Comente a linha que transforma o campo createdAt em Date"
	note="N√≥s entrela√ßamos o tipo User ao retorno da fun√ß√£o, ent√£o eles sempre ser√£o coerentes um ao outro"
/>

5. **Utilizando [generics](https://www.typescriptlang.org/docs/handbook/2/generics.html) para detectar os tipos**:
   Assim como outras linguagens, o TypeScript tamb√©m possui generics.

> üí° Uma forma simples de entender generics no TypeScript √© imaginar eles como par√¢metros. Assim como fun√ß√µes recebem par√¢metros comuns, elas tamb√©m recebem par√¢metros de tipos.
> Outros tipos tamb√©m podem aceitar generics, funcionando tamb√©m como par√¢metros.

<TypeScriptEditor
	code={`
  /** N√£o permite informar a chave 'id' */
  type ExceptId<TKeys> = Exclude<TKeys, 'id'>;
  
  // Criamos uma fun√ß√£o que recebe um objeto e o nome de uma chave presente no objeto
  declare function assertProperty<TSource>(
    source: TSource,
    key: ExceptId<keyof TSource>
  ): TSource;
  
  const user = { id: 1, name: 'Alan', email: 'test@localhost' };
  
  // A fun√ß√£o retorna o mesmo tipo do objeto que √© fornecido para ela
  const validUser = assertProperty(user, 'name');
  //    ^?
  
  // Tipos s√£o semelhantes a fun√ß√µes: recebem par√¢metros (generics) e retornam outro tipo
  type NonIdKeys = ExceptId<keyof typeof user>;
  //   ^?
`}
	tryItNote="Altere o par√¢metro 'name' ou adicione campos no objeto user"
	note="Ao utilizar generics nossos tipos se adaptam conforme o par√¢metro fornecido"
/>

6. **Trabalhando com dados constantes**: Quando voc√™ tem um objeto ou array constante (n√£o apenas `const`, mas efetivamente constante),
   o operador `as const` pode tornar os tipos mais espec√≠ficos.

<TypeScriptEditor
	code={`
  declare function say(message: string): void;
  
  // Declaramos uma vari√°vel efetivamente constante, ou seja, que nunca √© alterada
  const animals = [
    { kind: 'cat', meow: 'I am a cat!' },
    { kind: 'cat', meow: 'I am another cat!' },
    { kind: 'dog', bark: 'I am a dog!' },
    { kind: 'dog', bark: 'I am another dog!' },
  ] as const;
  
  type AnimalKind = typeof animals[number]['kind'];
  //   ^?
  
  animals.forEach((animal) => {
    // O TypeScript sabe quais objetos podem entrar em cada if
    if (animal.kind === 'cat') {
      say(animal.meow);
      //         ^?
    } else {
      say(animal.bark);
      //         ^?
    }
  });
`}
	tryItNote="Remova o operador as const ou adicione outro tipo de animal"
	note="Quando o TypeScript sabe que o valor √© constante, ele pode prever os tipos em cada cen√°rio"
/>

Esse artigo acaba por aqui. A ideia dele foi te convencer da import√¢ncia de melhorar os erros em tempo de compila√ß√£o,
al√©m de trazer alguns exemplos que sirvam de inspira√ß√£o quando que voc√™ for escrever suas interfaces e types.
Da pr√≥xima vez que for declarar um tipo, utilize um pouco mais de tempo para pensar como implement√°-lo de modo mais eficiente. At√© mais!
